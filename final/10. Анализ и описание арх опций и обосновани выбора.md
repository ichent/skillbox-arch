1. Обоснование выбора архитектурного стиля
    1. SBA (service based architecture). Я выбрал этот стиль как компромиссное решение между монолитом и микросервисами
    2. Почему не Монолит? (Проблема масштабируемости и надежности)
       1. Разнородная нагрузка: Модуль “Управление тренировками” является одвержен ярко выраженным нагрузкам (интенсивная запись телеметрии, логов датчиков). Остальные модули (профиль, инвентарь) — преимущественно чтение с равномерной нагрузкой.
       2. Независимое масштабирование: В монолите пришлось бы масштабировать всё приложение целиком, потребляя лишние ресурсы. SBA позволяет выделить “тяжелый” сервис тренировок на отдельные мощные инстансы, оставив Core-сервисы на минимальных ресурсах.
       3. Изоляция сбоев: Сбой в модуле “Геймификация” или “Инвентарь” (например, ошибка при начислении бонусов) не должен “ронять” критически важный функционал записи тренировки. Разделение сервисов гарантирует, что пользователь сохранит свой прогресс даже при падении второстепенных функций.
    3. Почему не Микросервисы? (Проблема сложности и избыточности)
       1. Высокая связность Core-доменов: Функции “Управление инвентарем”, “Профили”, “Геймификация” тесно связаны (пользователь получает достижения в профиль, за них дается инвентарь). Дробление их на отдельные микросервисы создаст неоправданный оверхед на сетевое взаимодействие и сложность обеспечения согласованности данных.
       2. Операционная сложность: Микросервисная архитектура требует сложной инфраструктуры (Service Discovery, Distributed Tracing, Circuit Breakers). На текущем этапе проекта это преждевременная оптимизация, которая замедлит Time-to-Market.
       3. Размер команд: SBA позволяет небольшой команде эффективно работать, не утопая в поддержке десятков репозиториев и пайплайнов CI/CD.
    4. Пригодность к эволюции (Evolvability): SBA — это эволюционный шаг. Если в будущем модуль “Геймификация” станет перегруженным, его можно будет безболезненно “отщепить” от Core-сервиса в отдельный микросервис, не переписывая всю систему.
2. Обоснование выбора Баз Данных (PostgreSQL)
   1. Для Core модуля (Профили, Инвентарь, Геймификация)
      1. Реляционная природа данных: Сущности “Пользователь”, “Ачивка”, “Предмет инвентаря” имеют четкую структуру и жесткие связи (Foreign Keys).
      2. Требования ACID: Операции с инвентарем и валютой (покупка предметов) требуют строгой консистентности. Транзакционная модель PostgreSQL гарантирует, что списанные очки не пропадут, если в момент выдачи предмета произойдет сбой.
      3. Сложные выборки: SQL позволяет эффективно выполнять аналитические запросы (например, “найти всех пользователей с уровнем > 5, у которых есть предмет X”), что затруднительно в NoSQL решениях.
