Разрабатываемая система представляет собой распределенное приложение, построенное на базе паттерна Microservices Architecture. Взаимодействие компонентов организовано через REST API для синхронных вызовов и брокер сообщений для асинхронных событийных цепочек.

Архитектура декомпозирована на следующие логические уровни:
1. Уровень клиента (Client Layer)

    1. Мобильное приложение (iOS/Android)
    2. Реализовано с использованием фреймворка Flutter (или Kotlin Multiplatform) для обеспечения единой кодовой базы.
        * Модуль Mobile Ingestion: Обеспечивает сбор телеметрии с сенсоров устройства (GPS, акселерометр) и подключенных по Bluetooth (BLE) внешних датчиков.
        * Локальное хранилище (Local-First): Использует встраиваемую СУБД Realm или SQLite для временного хранения данных тренировок и обеспечения Offline-режима (отложенная синхронизация при появлении сети).
        * Health API Adapter: Слой абстракции для унифицированного чтения данных из Apple HealthKit и Google Fit.
2. Уровень шлюза (API Gateway Layer)

    1. Единая точка входа в систему реализована на базе Nginx (или Spring Cloud Gateway). 2. Выполняет функции:
        * Терминация SSL/TLS трафика.
        * Маршрутизация запросов к соответствующим микросервисам.
        * Аутентификация запросов (валидация JWT-токенов).
        * Rate Limiting (защита от DDoS и перегрузки).
3. Уровень сервисов (Service Layer)

    Серверная логика разделена на независимые микросервисы (контейнеры Docker), сгруппированные по ограниченным контекстам (Bounded Contexts):

    1. Identity Service (Сервис идентификации):
        * Функции: Регистрация, аутентификация (OAuth2/OIDC), управление сессиями.
        * Стек: Go, PostgreSQL (хранение учетных записей).
    2. Training Core Service (Сервис тренировок):
        * Функции: Прием сырых данных тренировки, валидация треков, расчет базовых метрик (темп, дистанция).
        * Стек: Python (FastAPI) или Go, TimescaleDB (для хранения временных рядов телеметрии).
    3. Inventory Service (Сервис инвентаря):
        * Функции: CRUD операции с экипировкой, расчет износа на основе событий о завершении тренировок.
        * Стек: Java (Spring Boot), PostgreSQL.
    4. Gamification Service (Сервис геймификации):
        * Функции: Асинхронная обработка событий, начисление XP/баллов, управление лидербордами.
        * Стек: Java (Spring Boot), Redis (для быстрого чтения рейтингов).
    5. Social & Profile Service (Социальный граф):
        * Функции: Управление профилем, друзьями, поиск партнеров.
        * Стек: Node.js или Java, PostgreSQL.
    6. Notification Service (Сервис уведомлений):
        * Функции: Оркестрация отправки Push-уведомлений (через Firebase FCM) и Email.

4. Уровень данных и коммуникаций (Data & Integration Layer)

    1. Message Broker (RabbitMQ или Apache Kafka): Обеспечивает слабую связность (Low Coupling) между сервисами.
        * Пример: Training Service публикует событие TrainingFinished, на которое подписываются Gamification Service (для начисления баллов) и Inventory Service (для списания ресурса кроссовок).
    2. S3-совместимое хранилище (MinIO/AWS S3): Хранение статического медиа-контента (фотографии пользователей, иконки достижений).

5. Инфраструктурный уровень (Infrastructure)

    1. Приложение разворачивается в кластере Kubernetes (K8s), что обеспечивает автоматическое масштабирование (Horizontal Pod Autoscaler) и самовосстановление (Self-healing).
    2. CI/CD пайплайны (GitLab CI) осуществляют автоматическую сборку Docker-образов и деплой в кластер.
